# Overview
This package is intended only for use cases where you want a user operating in good faith to provide proof of completing some task within some given timeframe, without the overhead of storing secrets or implementing an HMAC-based totp auth.

Do not under any circumstances use this for login authentication or anything where security is important. The codes that are generated are not cryptographically secure and are *extremely* predictable; codes can be generated by piping the formatted output of `date -u` to md5sum.
This code will only work in circumstances where the machine providing the TOTP code and the machine verifying are synced to a reasonable degree of precision. A few seconds off is probably fine, but will decrease or increase the usability window of any given code.

By default, the timezone each host is configured to is irrelevant, as dates are hashed in UTC timezone. Because a custom timezone can be used, it's important that any programs validating codes should be compiled with the same locale information as the one generating codes.

# Usage
`GetCode()` will provide a 6-character TOTP code and a duration that the code is good for.

`DidDiligence()` will take that code and verify that *some* datetime within the Lookback period generates that code. Each second has a 1/16^6 chance of producing the same code as some other second, so the probability of an expired code finding a match is `P = 1 - [1 - (1/16)^6]^(Lookback / time.Second)`.

`DueDiligence()` will take a time.Time and generate a code. There's no real reason to use this function directly unless you want to provide a datetime that is something other than now().

`Locale` is exported so that a custom timezone name or offset can be used. Setting different locales for different tasks could be a way of ensuring that the generated code came from the expected generator.
